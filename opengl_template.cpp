/******************************************************************************
     * File: opengl_template.cpp
     * Description: Универсальный шаблон для создания простейших программ с
       помощью OpenGL GLUT.
     * Created: 08.01.2021
     * Author: Michael S2pac
******************************************************************************/

//#include <GL/glaux.h>  // функции, создающие простые трёхмерные геометрические объекты, \
                            функции, загружающие изображения из\
                            файлов, функции, работающие с окном вывода графики и т.д.
//#include <GL/gl.h>  // минимальный/стандартный набор функций для работы OpenGL
//#include <GL/glu.h>  // функции работы с матрицами, координатными системами, кривыми и поверхностями NURBS
#include <GL/glut.h>  // простая реализация оконного интерфейса

// Переменные, отвечающие за вращения
GLfloat dx_rot, dy_rot;
GLfloat ox_rot, oy_rot;

// Массив вершин отрисовываемых объектов
static GLfloat vert[] = {
        /// House
        -3, 3, 3,  // верхняя грань
        -3, 3, -3,
        3, 3, -3,
        3, 3, 3,

        -3, 3, 3,  // левая грань
        -3, 3, -3,
        -3, -3, -3,
        -3, -3, 3,

        -3, 3, -3,  // задняя грань
        3, 3, -3,
        3, -3, -3,
        -3, -3, -3,

        3, 3, -3,  // правая грань
        3, 3, 3,
        3, -3, 3,
        3, -3, -3,

        -3, 3, 3,  // передняя грань
        3, 3, 3,
        3, -3, 3,
        -3, -3, 3,

        -3, -3, 3,  // нижняя грань
        -3, -3, -3,
        3, -3, -3,
        3, -3, 3
};

static GLubyte colors[] = {
        123, 160, 91,
        123, 160, 91,
        123, 160, 91,
        123, 160, 91,

        39, 189, 219,
        39, 189, 219,
        39, 189, 219,
        39, 189, 219,

        94, 67, 49,
        94, 67, 49,
        94, 67, 49,
        94, 67, 49,

        94, 189, 49,
        94, 189, 49,
        94, 189, 49,
        94, 189, 49,

        39, 189, 54,
        39, 189, 54,
        39, 189, 54,
        39, 189, 54,

        39, 10, 219,
        39, 10, 219,
        39, 10, 219,
        39, 10, 219
};

// Функция перерисовки окна
void draw () {
    // Очистка буфера. При отсутствии очистки буфера цвета - картинка смазанная,
    // буфера глубины - ничего не отрисовывается и т.д.
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    /** Возможные параметры glClear()
    * GL_COLOR_BUFFER_BIT	Очистка буфера цвета
    * GL_DEPTH_BUFFER_BIT	Очистка буфера глубины
    * GL_ACCUM_BUFFER_BIT	Очистка буфера накопления
    * GL_STENCIL_BUFFER_BIT	Очистка буфера трафарета
    */


    // Перемещение камеры и вращение кубика
    glLoadIdentity();
    glTranslatef (0, 0, -10);
    glRotatef((ox_rot), 0, 1, 0);
    glRotatef((oy_rot), 1, 0, 0);


    /// Отрисовка домика
    // Мы будем использовать массивы вершин и цветов
    glEnableClientState(GL_VERTEX_ARRAY);
    glEnableClientState(GL_COLOR_ARRAY);

    // Загружаем массив в память
    glVertexPointer(3, GL_FLOAT, 0, vert);
    glColorPointer(3, GL_UNSIGNED_BYTE, 0, colors);
    /* glVertexPointer(GLint size, - указываем сколько значений будут описывать координаты точки, т.е. сколько-мерное пространство
                       GLenum type, - тип данных в котором храниться точка, например GL_SHORT, GL_INT, GL_FLOAT, GL_DOUBLE
                       GLsizei stride, -  смещение до следующующей группы координат. 0 - если данные уложены плотно
                       const GLvoid * pointer - имя массива с данными
                       );
    */

    // Отрисовка
    glDrawArrays(GL_QUADS, 0, 24);

    // Отключене массива
    glDisableClientState(GL_VERTEX_ARRAY);
    glDisableClientState(GL_COLOR_ARRAY);

    // Ставит буффер, который мы заполнили, на место активного буффера
    glFlush();
    /**
     * Выполнение программы не ждёт пока будет всё отрисовано, а позволяет перейти к следующим вычислениям.
     * Различные реализации GL буферизуют команды в нескольких различных местах, включая сетевые буферы
     * и сам графический ускоритель. glFlush опустошает все эти буферы,
     * заставляя все выданные команды выполняться так же быстро, как они принимаются фактическим механизмом рендеринга.
     * Хотя это выполнение не может быть завершено в какой-либо конкретный период времени, оно завершается в конечное время.
     *
     * При использовании двойной буферизации glFlush практически не имеет никакого эффекта,
     * так как изменения не будут видны до тех пор, пока вы не поменяете местами буферы!!!
     *
     * glFinish — приостанавливает выполнение программы, пока всё не будет отрисовано.
     * */
}

// Обработка нажатий клавиш
void key_pressed (unsigned char key, int x, int y){
    switch (key){
        // Обработка вращения куба
        case 'a':
            dx_rot += -0.5;
            break;
        case 'd':
            dx_rot += 0.5;
            break;
        case 'w':
            dy_rot += -0.5;
            break;
        case 's':
            dy_rot += 0.5;
            break;
        default:
            break;
    }
}

// "Итерация" отображения
void redraw () {
    ox_rot+=dx_rot;
    oy_rot+=dy_rot;

    // Вызов перерисовки
    glutPostRedisplay();

    /// Тут происходят изменения, связанные с анимацией
}

// Обработка изменения окна
void change_size(GLsizei w, GLsizei h) {
    // Высота окна не может быть 0
    if (h == 0)
        h = 1;

    // Как воспринимать матричные преобразования, которые будут сейачс происходить
    glMatrixMode(GL_PROJECTION);
    /** glMatrixMode задаёт, к стеку каких матриц будут применяться преобразования. Параметры функции:
    * GL_MODELVIEW  Матрицы для преобразования модели (объекта)
    * GL_PROJECTION Матрицы, используемые для преобразования перспективы или ортогонального преобразования
    * GL_TEXTURE    -"- текстур
    */

    glLoadIdentity(); // Сбрасывает матрицу обратно в её состояние по умолчанию
    /** glTranslate и glRotate всегда относятся к текущему состоянию матрицы.
     * Например, если вы вызываете glTranslate, вы переводите из текущей "позиции" матрицы, а не из начала координат.
     * Но если вы хотите начать с начала координат - тогда вы вызываете glLoadIdentity(),
     * а затем вы можете glTranslate из матрицы, которая теперь находится в начале координат,
     * или glRotate из матрицы, которая теперь ориентирована по умолчанию
     * */

    // Задаёт перспективу пирамиды (угол обзора, соотношение шириный окна к высоте,
    // минимальная дальность, максимальная дальность)
    gluPerspective(90, (GLdouble)w/h, 1, 300);

    gluLookAt(1., 1., 3.5, 0.5, 0., 0., 0., 1., 0.);
    /* eye* - позиция зрителя - взгляд "из" (точка в пространстве откуда мы наблюдаем).
     * center* - рассматриваемый объект - взгляд "на" (направление взгляда, куда смотрим).
     * .*/

    glMatrixMode(GL_MODELVIEW);

    // В какой части окна будет отрисовываться то, что мы задаём
    glViewport(0, 0, (GLdouble)w, (GLdouble)h);

    draw ();
}

// Настройки glut
int init_ogl (int argc, char** argv) {
    glClearColor(1.0f, 0.0f, 0.0f, 1.0f); // Задает значения очистки цветом буфера цвета

    // Инициализация glut
    glutInit(&argc, argv);
    glutInitWindowSize(640, 480);
    glutInitWindowPosition(0, 0);

    // Открытие окна
    glutCreateWindow("Template");

    // Выбор режима
    glutInitDisplayMode(GLUT_RGB | GLUT_SINGLE);
    /** Возмржные параметры функции glutInitDisplayMode ()
     * GLUT_RGB     Для отображения графической информации используются 3 компоненты цвета RGB.
     * GLUT_RGBA	То же что и RGB, но используется также 4 компонента ALPHA (прозрачность).
     * GLUT_INDEX	Цвет задается не с помощью RGB компонентов, а с помощью палитры. Используется для старых дисплеев,
                    где количество цветов например 256.
     * GLUT_SINGLE	Вывод в окно осуществляется с использованием 1 буфера. Обычно используется для статического вывода
                    информации.
     * GLUT_DOUBLE	Вывод в окно осуществляется с использованием 2 буферов. Применяется для анимации, чтобы исключить
                    эффект мерцания.
     * GLUT_ACCUM	Использовать также буфер накопления (Accumulation Buffer). Этот буфер применяется для создания специальных
                    эффектов, например отражения и тени.
     * GLUT_ALPHA	Использовать буфер ALPHA. Этот буфер, как уже говорилось используется для задания 4-го компонента цвета - ALPHA.
                    Обычно применяется для таких эффектов как прозрачность объектов и антиалиасинг.
     * GLUT_DEPTH	Создать буфер глубины. Этот буфер используется для отсечения невидимых линий в 3D пространстве при выводе на
                    плоский экран монитора.
     * GLUT_STENCIL	Буфер трафарета используется для таких эффектов как вырезание части фигуры, делая этот кусок прозрачным. Например,
                    наложив прямоугольный трафарет на стену дома, вы получите окно, через которое можно увидеть что находится внутри дома.
     * GLUT_STEREO	Этот флаг используется для создания стереоизображений. Используется редко, так как для просмотра такого изображения
                    нужна специальная аппаратура.
     */

    // Регистрация вызываемых функций
    glutDisplayFunc (draw);
    glutIdleFunc (redraw);
    glutReshapeFunc(change_size);
    /** Функции, связанные с событиями в OpenGL:
     * void glutDisplayFunc(void (*func)(void))
     Функция перерисовки окна.  glutPostRedisplay() вызывает ту функцию, которую передали в glutDisplayFunc() в качестве параметра
     * void glutReshapeFunc(void (*func)(int width, int height))
     Вызывается при изменении размеров окна. int width, int height - новые размеры.
     * void glutVisibilityFunc(void (*func)(int state))
     Окно становиться видимым или невидимым. Чтобы понять, что произошло, параметр state надо сравнить с GLUT_NOT_VISIBLE и GLUT_VISIBLE
     * void glutIdleFunc(void (*func)(void))
     Вызывается, когда приложение простаивает. Часто используют для анимации
     * void glutTimerFunc(unsigned int millis, void (*func)(int value), int value)
     Реализация таймера. value используется для идентификации таймера, если их несколько
    */

    /* Обработка нажатий клавиш - void glutKeyboardFunc(void (*func) (unsigned char key, int x, int y)). x и y - позиция курсора на экране,\
    key - код нажатой клавиши в кодировке ASCII */
    glutKeyboardFunc(key_pressed);

    // Тест глубины, чтобы задние грани рисовались сзади, а не поверх передних
    glEnable(GL_DEPTH_TEST);

    return 0;
}

int main (int argc, char** argv) {
    // Инициализаия OpenGL
    init_ogl (argc, argv);
    glutMainLoop();

    return 0;
}